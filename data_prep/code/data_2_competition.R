
# Script calculates a variety of competition measures


### includes the steps
# builds on data generated by 1_metainfo.R
# define different competition definitions
# identify neighbors and distance up to a max distance using spatstat.geom::closepairs()
# counts sums up N and BA for each focal tree
# neighbours are calculated for several splits to reduce memory requirements (without only on server)
# calculate overall density from con and het
# check output
# exports tree data




library(tidyr)
library(spatstat)
library(data.table)
library(dplyr)




# Settings ----------------------------------------------------------------

# plot range from metainfo
plotrange = plot$plotdimension


# nsplit based on object size
size = object.size(tree$tree1)/1e6 # in megabyte
nsplit = as.numeric(ceiling(size/8))
if (nsplit==0) nsplit = 1



# Distance definitions ----------------------------------------------------


# define distances
# becomes very slow if number of values is too large (e.g. 1:30)
dist_def = 30


# definitions of competition
setting <- purrr::cross(list(c("con", "het"), dist_def)) %>% 
  purrr::map(setNames, c("conhet", "distdef"))


# make varnames from settings without aggregation levels: N and ba
varname <- matrix(unlist(setting), nrow = length(setting), byrow = T)
varname <- apply(varname, 1, function(x) paste(x[1], "thresh", x[2], sep = "_"))

# range of decay values that should be tested (only for largest distance at the moment)
# sigma parameterization
decay =  c(seq(1, 4.5, 0.5), seq(5, 25, 1))
# previous (beta) parameterization beta = 1/sigma

# names for columns with exponential and exponential-normal decay
decay_names_exp = paste("exp", decay, sep = "_")
decay_names_expn = paste("expn", decay, sep = "_")
decay_names = c(decay_names_exp, decay_names_expn)











# Functions for competition -----------------------------------------------


# funtion to calculate different definitions of competition based on species and distance
comp <- function(setting, df) {
  
  # define neighbor as heterospecific or conspecific
  return(as.logical((df$sp_i != df$sp_j) * (eval(setting$conhet) == "het") +
                      (df$sp_i == df$sp_j) * (eval(setting$conhet) == "con"))   &
           
           # distance to neighbor < threshold
           df$d <= eval(setting$distdef))
  
}

dec <- function(sigma, df, type) {
  
  # adds a column with the scaling part for distance decay
  
  if (type == "exponential") {
    
    # exp(-beta*d)
    # beta = 1/sigma
    
    # calculate new column for exp(-beta*distance)
    return( exp(-(1/sigma)*df$d) )  
  }
  
  if (type == "exponential-normal") {
    
    # exp(-beta*d^2)
    # beta = 1/(sigma^2)
    
    # calculate new column for exp(-beta*distance)
    return( exp(-(1/(sigma^2))*(df$d^2)) )  
  }
  
}





# Calculate competition ---------------------------------------------------


for (level in c("tree")) {
  
  dat = get(level)
  
  
  for (census in names(dat)) { 
    
    
    # define focal trees in census (for analyses and as competitors)
    sel = grepl("A", dat[[census]]$status) # &     # only living trees
      # !is.na(dat[[census]]$gx)  # &              # only trees with coordinates
    # !is.na(dat[[census]]$ba) # &                 # only trees with ba
    
    
    dat_census = as.data.table(dat[[census]][sel, ])       
    
    # which of those are at the edge
    dat_census$edge = dat_census$gx < plotrange[1, 1]+max(dist_def) |
      dat_census$gx > plotrange[1, 2]-max(dist_def) |
      dat_census$gy < plotrange[2, 1]+max(dist_def) |
      dat_census$gy > plotrange[2, 2]-max(dist_def)
    
    
    # splitting the plot in a few parts to save memory
    splits = seq(plotrange[1, 1], plotrange[1, 2], length.out = nsplit+1)
    # dat_census$split = as.numeric(cut(dat_census$gx, breaks = splits))
    
    
    # generate dataframes to store results
    all_competition_n = data.frame()
    all_competition_ba =  data.frame()
    all_competition_n_dec_het =  data.frame()
    all_competition_n_dec_con =  data.frame()
    all_competition_ba_dec_het =  data.frame()
    all_competition_ba_dec_con =  data.frame()
    
    
    for (i in 1:nsplit) {
      
      flush.console()
      cat("\n", "census", gsub(level, "", census), "split", i, "out of", nsplit, "... Please wait!")
      
      # these are more than in split == i because of neighbors
      dat_census_split = dat_census[dat_census$gx <= splits[i+1]+max(dist_def) &
                                        dat_census$gx > splits[i]-max(dist_def), ]
      
      # which of those are too close to splits
      dat_census_split$edge_split = dat_census_split$gx <= splits[i] |
        dat_census_split$gx > splits[i+1]
      
      # create ppp for analyzing distances
      # closepairs is computationally more efficient than dist and others
      cat("\n", "calculating distances among neighbors")
      dat_ppp = spatstat.geom::ppp(dat_census_split$gx, dat_census_split$gy, 
                               window = owin(range(dat_census_split$gx), 
                                             range(dat_census_split$gy)), checkdup = F)
      neighbors = spatstat.geom::closepairs(dat_ppp, rmax = max(dist_def), 
                                       what = "ijd", twice = TRUE)
      # for number of neigbhors only one could also consider neighborspaircounts(), 
      # but probably not really helpful for different thresholds and species!
      
      neighbors = as.data.frame(neighbors) # faster with data.frame, later converted to data.table!
      
      
      # add additional columns
      neighbors$sp_i = dat_census_split$sp[neighbors$i]
      neighbors$sp_i[is.na(neighbors$sp_i)] = "other_i" # replace unknown species with dummy
      neighbors$edge_i = dat_census_split$edge[neighbors$i]
      neighbors$edge_split_i = dat_census_split$edge_split[neighbors$i]
      neighbors$sp_j = dat_census_split$sp[neighbors$j]
      neighbors$sp_j[is.na(neighbors$sp_j)] = "other_j" # replace unknown species with dummy
      neighbors$ba_j = dat_census_split$ba[neighbors$j]
      neighbors$j = NULL
      neighbors = as.data.table(neighbors)
      
      
      # remove focal trees i that are at the edge
      neighbors = neighbors[!(neighbors$edge_i | neighbors$edge_split_i), ]
      
      
      cat("\n", "calculating neighborhood definitions")
      
      # adds columns to neighbors for definitions of competition (from settings, doesn't include N and ba)
      neighbors[ , eval(varname) := lapply(setting, comp, df = neighbors)]
      
      # adds columns to neighbors for distance decay multiplier (see function dec())
      neighbors[ , eval(decay_names_exp) := lapply(decay, dec, df = neighbors, type = "exponential")]
      neighbors[ , eval(decay_names_expn) := lapply(decay, dec, df = neighbors, type = "exponential-normal")]
      
      
      cat("\n", "aggregating neighborhood definitions")
      
      # summarize competition columns at the tree level (i)
      # N: sum of TRUE
      competition_n <- neighbors[,
                                 lapply(.SD, sum),
                                 by = i,
                                 .SDcols = names(neighbors)[names(neighbors) %in% varname]]
      
      # basal area: sum of TRUE * ba
      competition_ba <- neighbors[,
                                  lapply(.SD, function(x) sum(x*ba_j, na.rm = T)),
                                  by = i,
                                  .SDcols = names(neighbors)[names(neighbors) %in% varname]]

      # decay columns
      # TRUE is either het_thresh_max or con_thresh_max
      # decay columns generated above  (see function dec())
      
      # N decay: sum of TRUE * decay 
      competition_n_dec_het <- neighbors[,
                                          lapply(.SD, function(x) sum(get(varname[length(varname)])*x, na.rm = T)),
                                          by = i,
                                          .SDcols = names(neighbors)[names(neighbors) %in% decay_names]]
      
      competition_n_dec_con <- neighbors[,
                                          lapply(.SD, function(x) sum(get(varname[length(varname)-1])*x, na.rm = T)),
                                          by = i,
                                          .SDcols = names(neighbors)[names(neighbors) %in% decay_names]]
      
      # ba decay: sum of TRUE * ba * decay 
      competition_ba_dec_het <- neighbors[,
                                          lapply(.SD, function(x) sum(get(varname[length(varname)])*ba_j*x, na.rm = T)),
                                          by = i,
                                          .SDcols = names(neighbors)[names(neighbors) %in% decay_names]]
      
      competition_ba_dec_con <- neighbors[,
                                          lapply(.SD, function(x) sum(get(varname[length(varname)-1])*ba_j*x, na.rm = T)),
                                          by = i,
                                          .SDcols = names(neighbors)[names(neighbors) %in% decay_names]]
      
      
      
      
      cat("\n", "preparing for data")
      
      # assign treeID to competition objects
      competition_n$treeID  <- dat_census_split$treeID[competition_n$i]
      competition_ba$treeID <- dat_census_split$treeID[competition_ba$i]
      competition_n_dec_het$treeID <- dat_census_split$treeID[competition_n_dec_het$i]
      competition_n_dec_con$treeID <- dat_census_split$treeID[competition_n_dec_con$i]
      competition_ba_dec_het$treeID <- dat_census_split$treeID[competition_ba_dec_het$i]
      competition_ba_dec_con$treeID <- dat_census_split$treeID[competition_ba_dec_con$i]
      
      
      # add zero competition for main stems that are missing in competition objects
      # but are also no edge trees!!!
      noNeighbors = dat_census_split$treeID[!dat_census_split$treeID %in% competition_n$treeID & 
                                               !dat_census_split$edge &
                                               !dat_census_split$edge_split]
      
      if (length(noNeighbors) > 0) {
        competition_n = rbind(competition_n, 
                              data.table(i = NA, treeID = noNeighbors)[, eval(varname) := 0])
        competition_ba = rbind(competition_ba, 
                               data.table(i = NA, treeID = noNeighbors)[, eval(varname) := 0])
        competition_n_dec_het = rbind(competition_n_dec_het, 
                                       data.table(i = NA, treeID = noNeighbors)[, eval(c(decay_names)) := 0])
        competition_n_dec_con = rbind(competition_n_dec_con, 
                                       data.table(i = NA, treeID = noNeighbors)[, eval(c(decay_names)) := 0])
        competition_ba_dec_het = rbind(competition_ba_dec_het, 
                                       data.table(i = NA, treeID = noNeighbors)[, eval(c(decay_names)) := 0])
        competition_ba_dec_con = rbind(competition_ba_dec_con, 
                                       data.table(i = NA, treeID = noNeighbors)[, eval(c(decay_names)) := 0])
        
      }
      
      # combine with other splits
      all_competition_n = rbind(all_competition_n, competition_n)
      all_competition_ba = rbind(all_competition_ba, competition_ba)
      all_competition_n_dec_het = rbind(all_competition_n_dec_het, competition_n_dec_het)
      all_competition_n_dec_con = rbind(all_competition_n_dec_con, competition_n_dec_con)
      all_competition_ba_dec_het = rbind(all_competition_ba_dec_het, competition_ba_dec_het)
      all_competition_ba_dec_con = rbind(all_competition_ba_dec_con, competition_ba_dec_con)
    }
    
    
    # # for checking duplication problems
    # table(duplicated(all_competition_ba$treeID))
    # temp = all_competition_ba$treeID[duplicated(all_competition_ba$treeID)]
    # all_competition_ba[all_competition_ba$treeID %in% temp[length(temp)], ]
    
    cat("\n", "assign competition to data")
    
    # all competition objects have the same length and order
    temp = match(dat[[census]]$treeID, all_competition_n$treeID)
    
    dat[[census]][, paste0("n_", varname)] <- all_competition_n[temp, ..varname]
    dat[[census]][, paste0("ba_", varname)] <- all_competition_ba[temp, ..varname]
    dat[[census]][, paste0("n_het_", decay_names)] <- all_competition_n_dec_het[temp, ..decay_names]
    dat[[census]][, paste0("n_con_", decay_names)] <- all_competition_n_dec_con[temp, ..decay_names]
    dat[[census]][, paste0("ba_het_", decay_names)] <- all_competition_ba_dec_het[temp, ..decay_names]
    dat[[census]][, paste0("ba_con_", decay_names)] <- all_competition_ba_dec_con[temp, ..decay_names]
    
  }
  assign(level, dat)
}




# Calculate overall density -----------------------------------------------


for (j in c("n_", "ba_")) {
  
  varall = gsub(paste0(j, "het_"), "", names(tree[[1]])[grepl(paste0(j, "het_"), names(tree[[1]]))])
  
  for (i in varall) {
    
    for (census in names(tree)) {
      
      # all = con + het
      tree[[census]][, paste0(j, "all_", i)] = tree[[census]][, paste0(j, "het_", i)] + tree[[census]][, paste0(j, "con_", i)]
      
      # remove columns for heterospecific densities
      tree[[census]][, paste0(j, "het_", i)] = NULL
    }
  }
}










